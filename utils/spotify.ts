import { find, flattenDeep, shuffle } from 'lodash';

import fetch from 'node-fetch';
import { serialAsyncForEach } from '.';

let accessToken: string | null = null;

export const setAccessToken = (token: string) => accessToken = token;

const performRequest = (url, method: string = 'GET', body?: any) =>
  fetch(url, {
    method: method,
    body: body ? JSON.stringify(body) : undefined,
    headers: {
      Authorization: `Bearer ${accessToken}`,
    }
  })
    .then(response => {
      if (response.ok)
        return response.json();

      throw new Error(`${response.status} ${response.statusText}`);
    })

const fetchSavedTracks = async (items: any[] = [], url: string = null) => {
  const response = await performRequest(url || `https://api.spotify.com/v1/me/tracks?offset=0&limit=50`);
  const cItems = [...items, ...response.items];

  if (response.next)
    return fetchSavedTracks(cItems, response.next);
  else
    return cItems;
}

const fetchSavedPlaylists = async (items: any[] = [], url: string = null) => {
  const response = await performRequest(url || `https://api.spotify.com/v1/me/playlists?offset=0&limit=50`);
  const cItems = [...items, ...response.items];

  if (response.next)
    return fetchSavedPlaylists(cItems, response.next);
  else
    return cItems;
}

const fetchPlaylistItemURLs = async (playlistId: string, items: any[] = [], url: string = null) => {
  const response = await performRequest(url || `https://api.spotify.com/v1/playlists/${playlistId}/tracks?fields=limit,next,items(track(uri))&limit=100`);
  const cItems = [...items, ...response.items.map(i => i.track.uri)];

  if (response.next)
    return fetchPlaylistItemURLs(playlistId, cItems, response.next);
  else
    return cItems;
}

const fetchUserInfo = () =>
performRequest(`https://api.spotify.com/v1/me`);

const getRecommendations = (seedTrack: string, limit: number) =>
performRequest(`https://api.spotify.com/v1/recommendations?seed_tracks=${seedTrack}&limit=${limit}`);

const fetchAllSavedTracks = () => fetchSavedTracks();
const fetchAllSavedPlaylists = () => fetchSavedPlaylists();
const fetchAllPlaylistTrackUris = (playlistId: string) => fetchPlaylistItemURLs(playlistId);

const getExistingPlaylist = async (userId: string, name: string) => {
  const playlists = await fetchAllSavedPlaylists();
  const existing = find(playlists, (i) => (i.owner.id === userId && i.name === name));
  return existing;
}

const emptyPlaylist = async (playlistId: string) => {
  const uris = await fetchAllPlaylistTrackUris(playlistId);
  const response = await performRequest(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, 'DELETE', {
    tracks: uris.map(uri => ({ uri: uri })),
  });
  return response;
}

const createPlaylist = (userId: string, name: string) =>
  performRequest(`https://api.spotify.com/v1/users/${userId}/playlists`, 'POST', {
    name,
    public: false,
    collaborative: false,
    description: 'Autogenerated playlist by Random Daily Drive',
  });

const addTracks = (playlistId: string, uris: string[]) =>
  performRequest(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, 'POST', {
    uris: uris
  });

export const generateDailyDrive = async (name: string, blocks: number, blockSize: number) => {
  const user = await fetchUserInfo();

  let playlist = await getExistingPlaylist(user.id, name);

  if (playlist)
    await emptyPlaylist(playlist.id);
  else
    playlist = await createPlaylist(user.id, name);

  const tracks = await fetchAllSavedTracks();
  const seedTracks = shuffle(tracks).slice(0, blocks).map(i => i.track);

  const recommendedBlocks = [];

  await serialAsyncForEach(seedTracks, async (track) => {
    const recommendations = await getRecommendations(track.id, blockSize - 1)
    recommendedBlocks.push(track.uri);
    recommendedBlocks.push(recommendations.tracks.map(i => i.uri));
    return;
  });
  await addTracks(playlist.id, flattenDeep(recommendedBlocks));
  return playlist;
}
