import { filter, find, flattenDeep, shuffle, startsWith } from 'lodash';
import { serialAsyncForEach } from '.';

let accessToken: string | null = null;

export const setAccessToken = (token: string) => accessToken = token;

const performRequest = (url: string, method: string = 'GET', body?: any) =>
  fetch(url, {
    method: method,
    body: body ? JSON.stringify(body) : undefined,
    headers: {
      Authorization: `Bearer ${accessToken}`,
    }
  })
    .then(response => {
      if (response.ok)
        return response.json();

      throw new Error(`${response.status} ${response.statusText}`);
    })

const fetchSavedTracks = async (items: any[] = [], url: string|null = null): Promise<any[]> => {
  const response = await performRequest(url || `https://api.spotify.com/v1/me/tracks?offset=0&limit=50`);
  const cItems = [...items, ...response.items];

  if (response.next)
    return fetchSavedTracks(cItems, response.next);
  else
    return cItems;
}

const fetchSavedPlaylists = async (items: any[] = [], url: string|null = null): Promise<any[]> => {
  const response = await performRequest(url || `https://api.spotify.com/v1/me/playlists?offset=0&limit=50`);
  const cItems = [...items, ...response.items];

  if (response.next)
    return fetchSavedPlaylists(cItems, response.next);
  else
    return cItems;
}

const fetchPlaylistItemURLs = async (playlistId: string, items: any[] = [], url: string|null = null): Promise<string[]> => {
  const response = await performRequest(url || `https://api.spotify.com/v1/playlists/${playlistId}/tracks?fields=limit,next,items(track(uri))&limit=100`);
  const cItems = [...items, ...response.items.map((i: any) => i.track ? i.track.uri : null).filter((i: string) => i)];

  if (response.next)
    return fetchPlaylistItemURLs(playlistId, cItems, response.next);
  else
    return cItems;
}

const fetchUserInfo = () =>
  performRequest(`https://api.spotify.com/v1/me`);

const getRecommendations = (seedTrack: string, limit: number) =>
  performRequest(`https://api.spotify.com/v1/recommendations?seed_tracks=${seedTrack}&limit=${limit}`);

const fetchAllSavedTracks = () => fetchSavedTracks();
const fetchAllSavedPlaylists = () => fetchSavedPlaylists();
const fetchAllPlaylistTrackUris = (playlistId: string): Promise<string[]> => fetchPlaylistItemURLs(playlistId)

const getExistingPlaylist = async (userId: string, name: string) => {
  const playlists = await fetchAllSavedPlaylists();
  const existing = find(playlists, (i) => (i.owner.id === userId && i.name === name));
  return existing;
}

const emptyPlaylist = async (playlistId: string) => {
  const uris = await fetchAllPlaylistTrackUris(playlistId);
  const response = await performRequest(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, 'DELETE', {
    tracks: uris.map(uri => ({ uri: uri })),
  });
  return response;
}

const createPlaylist = (userId: string, name: string) =>
  performRequest(`https://api.spotify.com/v1/users/${userId}/playlists`, 'POST', {
    name,
    public: false,
    collaborative: false,
    description: 'Autogenerated playlist by Random Daily Drive',
  });

const addTracks = (playlistId: string, uris: string[]) =>
  performRequest(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, 'POST', {
    uris: uris
  });

/**
 * Fetches the podcast episodes from the original Daily Drive playlist
 * Unfortunateley there is no better way to search the list than do it like this, it's not guaranteed we find it.
 */
const fetchDailyDrivePodcasts = async () => {
  const searchResult = await performRequest(`https://api.spotify.com/v1/search/?type=playlist&q="Your Daily Drive"&limit=50`);
  // FIXME: what are the names of the Daily Drive playlist in other languages? Is there any way to universally identifiy that playlist?
  const dailyDrive = find(searchResult.playlists.items, (item) => (item.owner.id === 'spotify' && (item.name === 'Your Daily Drive' || item.name === 'Daily Drive' )) );

  if (!dailyDrive) {
    console.warn('Your Daily Drive could not be found. Skipping including podcasts.')
    return null;
  }

  const allTracks = await fetchAllPlaylistTrackUris(dailyDrive.id);
  const episodes = filter(allTracks, (uri) => startsWith(uri, 'spotify:episode:'));
  return episodes;
}

export const generateDailyDrive = async (name: string, blocks: number, blockSize: number, withPodcasts: boolean) => {
  const user = await fetchUserInfo();

  let playlist = await getExistingPlaylist(user.id, name);

  if (playlist)
    await emptyPlaylist(playlist.id);
  else
    playlist = await createPlaylist(user.id, name);

  const tracks = await fetchAllSavedTracks();
  const seedTracks = shuffle(tracks).slice(0, blocks).map(i => i.track);

  const recommendedBlocks = [];

  let episodeUris = null;
  if (withPodcasts)
    episodeUris = await fetchDailyDrivePodcasts();

  await serialAsyncForEach(seedTracks, async (track) => {
    const recommendations = await getRecommendations(track.id, blockSize - 1)
    if (episodeUris) {
      const episodeUri = episodeUris.shift();
      if (episodeUri)
        recommendedBlocks.push(episodeUri);
    }
    recommendedBlocks.push(track.uri);
    recommendedBlocks.push(recommendations.tracks.map((i: any) => i.uri));
    return;
  });

  // finally if we have more podcasts left than blocks, we'll add them all in the last block
  if (episodeUris && episodeUris.length > 0) {
    recommendedBlocks.push(...episodeUris);
  }

  await addTracks(playlist.id, flattenDeep(recommendedBlocks));
  return playlist;
}
