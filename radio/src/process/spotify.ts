import { filter, find, startsWith, shuffle, concat, uniqBy } from "lodash";

let _accessToken: string | null = null;

export const setAccessToken = (token: string) => (_accessToken = token);

const performRequest = (url: string, method: string = "GET", body?: any) =>
  fetch(url, {
    method,
    body: body ? JSON.stringify(body) : undefined,
    headers: {
      Authorization: `Bearer ${_accessToken}`,
    },
  }).then((response) => {
    if (response.status === 429) {
      console.log({ response });
      console.log(response.json());
      return { status: 429, headers: response.headers.entries() };
    }

    if (response.ok) {
      return response.json();
    }

    console.error(
      `An error occurred: ${response.status} ${response.statusText}`
    );
    return { error: true };
  });

const sleep = (seconds: number) => {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};

/* User **/

const fetchUserInfo = () => performRequest(`https://api.spotify.com/v1/me`);

/* Playlists **/

const fetchSavedPlaylists = async (items: any[] = [], url: string = null) => {
  const response = await performRequest(
    url || `https://api.spotify.com/v1/me/playlists?offset=0&limit=50`
  );
  const cItems = [...items, ...response.items];

  if (response.next) return fetchSavedPlaylists(cItems, response.next);
  else return cItems;
};

const fetchPlaylistItemURLs = async (
  playlistId: string,
  items: any[] = [],
  url: string = null
) => {
  const response = await performRequest(
    url ||
      `https://api.spotify.com/v1/playlists/${playlistId}/tracks?fields=limit,next,items(track(uri))&limit=100`
  );
  const cItems = [
    ...items,
    ...response.items
      .map((i) => (i.track ? i.track.uri : null))
      .filter((i) => i),
  ];

  if (response.next)
    return fetchPlaylistItemURLs(playlistId, cItems, response.next);
  else return cItems;
};

const fetchAllPlaylistTrackUris = (playlistId: string) =>
  fetchPlaylistItemURLs(playlistId);

const getExistingPlaylist = async (userId: string, name: string) => {
  const playlists = await fetchSavedPlaylists();
  const existing = find(
    playlists,
    (i) => i.owner.id === userId && i.name === name
  );
  return existing;
};

const emptyPlaylist = async (playlistId: string) => {
  const uris = await fetchAllPlaylistTrackUris(playlistId);
  const response = await performRequest(
    `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
    "DELETE",
    {
      tracks: uris.map((uri) => ({ uri: uri })),
    }
  );
  return response;
};

const createPlaylist = (userId: string, name: string) =>
  performRequest(
    `https://api.spotify.com/v1/users/${userId}/playlists`,
    "POST",
    {
      name,
      public: false,
      collaborative: false,
      description: "Autogenerated playlist by Random Daily Drive",
    }
  );

const addTracks = (playlistId: string, uris: string[]) =>
  performRequest(
    `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
    "POST",
    {
      uris,
    }
  );

/**
 * Fetches the music from the original Daily Drive playlist.
 * Unfortunateley there is no better way to search the list than do it like this, it's not guaranteed we find it.
 */
const fetchDailyDriveMusic = async (
  appendMessage: (message: string) => void
) => {
  const searchResult = await performRequest(
    `https://api.spotify.com/v1/search/?type=playlist&q="Ruta Diaria"&limit=50`
  );

  const dailyDrive = find(
    searchResult.playlists.items,
    (item) =>
      item.owner.id === "spotify" &&
      (item.name === "Your Daily Drive" ||
        item.name === "Daily Drive" ||
        item.name === "Ruta diaria")
  );

  if (!dailyDrive) {
    appendMessage(
      "Daily Drive playlist could not be found. Skipping including music..."
    );
    return null;
  }

  const allItems = await fetchAllPlaylistTrackUris(dailyDrive.id);

  const tracks = filter(
    allItems,
    // Also removes the first track, which is neither music nor a podcast but a spoken introduction.
    // There's a more elegant way to do this but it's good enough.
    (uri, index) => index !== 0 && startsWith(uri, "spotify:track:")
  );
  return tracks;
};

/* Tracks **/

const fetchUserTopTracks = async (
  blockSize: number,
  appendMessage: (message: string) => void
) => {
  const topSongsPerBlock = Math.ceil(blockSize / 2);
  const newSongsPerBlock = Math.floor(blockSize / 2);

  await sleep(1);

  const topTracksShortTerm0 = await performRequest(
    `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=short_term&offset=0`
  );

  await sleep(1);

  const topTracksShortTerm1 =
    blockSize < 3
      ? []
      : await performRequest(
          `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=short_term&offset=49`
        );

  await sleep(1);

  const topTracksMediumTerm0 = await performRequest(
    `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=medium_term&offset=0`
  );

  await sleep(1);

  const topTracksMediumTerm1 =
    blockSize < 3
      ? []
      : await performRequest(
          `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=medium_term&offset=49`
        );

  await sleep(1);

  const topTracksLongTerm0 = await performRequest(
    `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=long_term&offset=0`
  );

  await sleep(1);

  const topTracksLongTerm1 =
    blockSize < 3
      ? []
      : await performRequest(
          `https://api.spotify.com/v1/me/top/tracks?limit=50&time_range=long_term&offset=40`
        );

  const topTracks = uniqBy(
    concat(
      topTracksShortTerm0.items,
      topTracksShortTerm1.items,
      topTracksMediumTerm0.items,
      topTracksMediumTerm1.items,
      topTracksLongTerm0.items,
      topTracksLongTerm1.items
    ),
    (element) => element.artists[0].name
  );

  const shuffledTopTracks = shuffle(topTracks).slice(0, 10 * topSongsPerBlock);

  await sleep(1);

  let allRecommendations = [];
  for (let i = 0; i < shuffledTopTracks.length; i += topSongsPerBlock) {
    const trackRecommendations = await getRecommendations(
      shuffledTopTracks[i].id,
      newSongsPerBlock
    );

    if (trackRecommendations.status === 429) {
      appendMessage(
        `Rate limit reached. Can't hit the recommendation API. Switching to using the user's random top tracks...`
      );

      const shuffledTopTrackWithoutRecommendations = shuffle(topTracks).slice(
        0,
        10 * blockSize
      );

      let shuffledTopTracksUris = [];
      for (let p = 0; p < shuffledTopTrackWithoutRecommendations.length; p++) {
        shuffledTopTracksUris.push(
          shuffledTopTrackWithoutRecommendations[p].uri
        );
        console.log(shuffledTopTrackWithoutRecommendations[p]);
        appendMessage(
          `Selected: ${shuffledTopTrackWithoutRecommendations[p].artists[0].name} - ${shuffledTopTrackWithoutRecommendations[p].name} [top track]`
        );
      }

      return shuffledTopTracksUris;
      // return fetchDailyDriveMusic(appendMessage);
    }

    await sleep(1);

    let yolo = [];
    if (topSongsPerBlock > 1) {
      yolo = shuffledTopTracks.slice(
        1 + i * blockSize,
        1 + i * blockSize + topSongsPerBlock - 1
      );
      for (let h = 0; h < yolo.length; h++) {
        appendMessage(
          `Selected: ${yolo[h].artists[0].name} - ${yolo[h].name} [standalone track]`
        );
      }
    }

    appendMessage(
      `Selected: ${shuffledTopTracks[i].artists[0].name} - ${shuffledTopTracks[i].name} [seed track]`
    );

    if (!trackRecommendations.error) {
      for (let j = 0; j < trackRecommendations.tracks.length; j++) {
        appendMessage(
          `Selected: ${trackRecommendations.tracks[j].artists[0].name} - ${trackRecommendations.tracks[j].name} [recommendation track]`
        );
      }
    }

    allRecommendations = [
      ...allRecommendations,
      ...yolo.map((track) => track.uri),
      shuffledTopTracks[i].uri,
      ...(!trackRecommendations.error &&
        trackRecommendations.tracks.map((track) => track.uri)),
    ];
  }

  return allRecommendations;
};

const getRecommendations = (seedTrackId: string, limit: number) =>
  performRequest(
    `https://api.spotify.com/v1/recommendations?seed_tracks=${seedTrackId}&limit=${limit}`
  );

/* Podcasts **/

const fetchUserPodcasts = async (appendMessage: (message: string) => void) => {
  const podcastLimitPerPage = 50;

  await sleep(1);

  const podcasts = await performRequest(
    `https://api.spotify.com/v1/me/shows?offset=0&limit=${podcastLimitPerPage}`
  );

  if (!podcasts) {
    return;
  }

  const totalPodcasts = podcasts.total;
  if (totalPodcasts > podcastLimitPerPage) {
    // TODO: Handle case where users has saved more podcasts than pagination limit.
    appendMessage(
      `Found ${totalPodcasts} podcasts but pagination limit set to ${[
        podcastLimitPerPage,
      ]}. ${totalPodcasts - podcastLimitPerPage} podcasts will be ignored.`
    );
  } else {
    appendMessage(`Found ${totalPodcasts} podcasts.`);
  }

  return podcasts;
};

const fetchEpisodesOfPodcast = async (podcast, maximumDuration) => {
  const episodes = await performRequest(
    `https://api.spotify.com/v1/shows/${podcast.show.id}/episodes`
  );

  const episodeMatch = episodes.items.filter(
    (episode) =>
      episode.duration_ms <= maximumDuration * 1000 * 60 &&
      !episode.resume_point.fully_played
  );

  if (episodeMatch.length > 0) {
    return episodeMatch[0];
  }
};

const fetchEpisodesToInsert = async (
  podcasts,
  musicUris,
  blockSize,
  maximumDuration,
  appendMessage: (message: string) => void
) => {
  const episodesNeeded = Math.floor(musicUris.length / blockSize);
  appendMessage(`${episodesNeeded} podcast episodes will be needed.`);

  const podcastsWithoutAudiobooks = podcasts.items.filter(
    (podcast) => !podcast.show.description.startsWith("Author(s): ")
  );

  appendMessage(
    `Updated count of podcasts to ${podcastsWithoutAudiobooks.length} after removing audiobooks.`
  );

  appendMessage("Shuffling podcasts...");
  const shuffledPodcasts = shuffle(podcastsWithoutAudiobooks);
  const selectedPodcasts = shuffledPodcasts.slice(0, episodesNeeded);
  let unusedPodcasts = shuffledPodcasts.slice(episodesNeeded + 1);

  await sleep(1);

  appendMessage(`Fetching podcast episodes...`);
  let episodeUris = [];
  let episode = null;
  let selectedPodcast = {} as any;
  for (let i = 0; i < selectedPodcasts.length; i++) {
    selectedPodcast = selectedPodcasts[i].show;
    episode = await fetchEpisodesOfPodcast(
      selectedPodcasts[i],
      maximumDuration
    );

    await sleep(1);

    let j = 0;
    while (!episode && unusedPodcasts.length) {
      if (!unusedPodcasts[j]) {
        break;
      }

      selectedPodcast = unusedPodcasts[j].show;
      appendMessage(`Digging in more podcasts: ${selectedPodcast.name}...`);

      episode = await fetchEpisodesOfPodcast(
        unusedPodcasts[j],
        maximumDuration
      );

      await sleep(1);

      unusedPodcasts = unusedPodcasts.filter(
        (unusedPodcast) => unusedPodcast.show.id !== selectedPodcast.id
      );
      j++;
    }

    if (episode) {
      appendMessage(
        `Selected: ${selectedPodcast.name} - ${episode.name} (${Math.floor(
          episode.duration_ms / 1000 / 60
        )} minutes)`
      );

      episodeUris.push(episode.uri);
    }
  }

  return episodeUris;
};

/* All the things **/

const insertEpisodes = (musicUris, episodeUris, blockSize) => {
  const mergedUris = [...musicUris];
  const insertEveryNElements = blockSize;
  const elementsToInsert = episodeUris.length;

  for (let i = 1; i <= elementsToInsert; i++) {
    const indexToInsert = i * insertEveryNElements + (i - 1);
    if (episodeUris[i - 1]) {
      mergedUris.splice(indexToInsert, 0, episodeUris[i - 1]);
    }
  }

  return mergedUris;
};

export const generateDailyDrive = async (
  name: string,
  blockSize: number,
  maximumDuration: number,
  accessToken: string | null,
  appendMessage: (message: string) => void
) => {
  setAccessToken(accessToken);
  appendMessage(null);

  if (!accessToken) {
    appendMessage("Access token missing. Please log in again.");
    return;
  }

  appendMessage("Fetching user info...");
  const user = await fetchUserInfo();

  if (!user.id) {
    appendMessage("User ID not found.");
    return;
  }

  appendMessage(`Found user with ID ${user.id}.`);

  // TODO: Generate my own set of music tracks rather than relying on the Daily Drive playlist, relying on the recommendation API.
  appendMessage("Fetching music tracks from user's top songs...");
  let musicUris = null;
  musicUris = await fetchUserTopTracks(blockSize, appendMessage);

  if (!musicUris) {
    appendMessage(
      "Something went wrong. No music tracks were found. Abandoning playlist generation..."
    );
    return;
  }

  appendMessage(`Got ${musicUris.length} music tracks.`);

  appendMessage("Fetching podcasts followed by the user...");
  let podcasts = await fetchUserPodcasts(appendMessage);

  if (!podcasts) {
    appendMessage("No podcasts saved by the user were found.");
  }

  const episodeUris = await fetchEpisodesToInsert(
    podcasts,
    musicUris,
    blockSize,
    maximumDuration,
    appendMessage
  );

  if (!episodeUris) {
    appendMessage("No podcast episodes were found.");
  }

  const trackUris = insertEpisodes(musicUris, episodeUris, blockSize);

  appendMessage(
    `Size of merged music tracks and podcast episodes: ${trackUris.length}.`
  );

  await sleep(1);

  appendMessage(`Checking for the existence of playlist "${name}"...`);
  let playlist = await getExistingPlaylist(user.id, name);

  await sleep(1);

  if (playlist) {
    appendMessage(`Found existing playlist with ID ${playlist.id}.`);
    appendMessage("Emptying the existing playlist...");

    await sleep(1);

    await emptyPlaylist(playlist.id);
  } else {
    appendMessage(`Creating new playlist "${name}"...`);

    await sleep(1);

    playlist = await createPlaylist(user.id, name);
    appendMessage(`Created playlist with ID ${playlist.id}.`);
  }

  await sleep(1);

  appendMessage("Adding music tracks to the playlist...");
  const response = await addTracks(playlist.id, trackUris);

  if (response.error) {
    console.log({ trackUris, episodeUris, musicUris, podcasts, user });
    appendMessage(
      "An error occurred when adding music tracks to the playlist."
    );
  }

  return playlist;
};
