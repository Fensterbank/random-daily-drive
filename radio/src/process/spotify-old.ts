import { filter, find, flattenDeep, shuffle, startsWith } from "lodash";

let accessToken: string | null = null;

export const setAccessToken = (token: string) => (accessToken = token);

/**
 * This method runs over an array of items and calls a method with the item as first parameter
 * @param arr The array of items
 * @param asyncMethod The async method which will be called with the item as first parameter
 */
const serialAsyncForEach = (
  arr: any[],
  asyncMethod: (item: any) => Promise<any>
) =>
  arr.reduce(
    (accPromise, item) => accPromise.then(() => asyncMethod(item)),
    Promise.resolve()
  );

const performRequest = (url, method: string = "GET", body?: any) =>
  fetch(url, {
    method: method,
    body: body ? JSON.stringify(body) : undefined,
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  }).then((response) => {
    if (response.ok) return response.json();

    console.error(`${response.status} ${response.statusText}`);
  });

const fetchSavedTracks = async (items: any[] = [], url: string = null) => {
  const response = await performRequest(
    url || `https://api.spotify.com/v1/me/tracks?offset=0&limit=50`
  );
  const cItems = [...items, ...response.items];

  if (response.next) return fetchSavedTracks(cItems, response.next);
  else return cItems;
};

const fetchSavedPlaylists = async (items: any[] = [], url: string = null) => {
  const response = await performRequest(
    url || `https://api.spotify.com/v1/me/playlists?offset=0&limit=50`
  );
  const cItems = [...items, ...response.items];

  if (response.next) return fetchSavedPlaylists(cItems, response.next);
  else return cItems;
};

const fetchPlaylistItemURLs = async (
  playlistId: string,
  items: any[] = [],
  url: string = null
) => {
  const response = await performRequest(
    url ||
      `https://api.spotify.com/v1/playlists/${playlistId}/tracks?fields=limit,next,items(track(uri))&limit=100`
  );
  const cItems = [
    ...items,
    ...response.items
      .map((i) => (i.track ? i.track.uri : null))
      .filter((i) => i),
  ];

  if (response.next)
    return fetchPlaylistItemURLs(playlistId, cItems, response.next);
  else return cItems;
};

const fetchUserInfo = () => performRequest(`https://api.spotify.com/v1/me`);

const getRecommendations = (seedTrack: string, limit: number) =>
  performRequest(
    `https://api.spotify.com/v1/recommendations?seed_tracks=${seedTrack}&limit=${limit}`
  );

const fetchAllSavedTracks = () => fetchSavedTracks();
const fetchAllSavedPlaylists = () => fetchSavedPlaylists();
const fetchAllPlaylistTrackUris = (playlistId: string) =>
  fetchPlaylistItemURLs(playlistId);

const getExistingPlaylist = async (userId: string, name: string) => {
  const playlists = await fetchAllSavedPlaylists();
  const existing = find(
    playlists,
    (i) => i.owner.id === userId && i.name === name
  );
  return existing;
};

const emptyPlaylist = async (playlistId: string) => {
  const uris = await fetchAllPlaylistTrackUris(playlistId);
  const response = await performRequest(
    `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
    "DELETE",
    {
      tracks: uris.map((uri) => ({ uri: uri })),
    }
  );
  return response;
};

const createPlaylist = (userId: string, name: string) =>
  performRequest(
    `https://api.spotify.com/v1/users/${userId}/playlists`,
    "POST",
    {
      name,
      public: false,
      collaborative: false,
      description: "Autogenerated playlist by Random Daily Drive",
    }
  );

const addTracks = (playlistId: string, uris: string[]) =>
  performRequest(
    `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
    "POST",
    {
      uris: uris,
    }
  );

/**
 * Fetches the podcast episodes from the original Daily Drive playlist
 * Unfortunateley there is no better way to search the list than do it like this, it's not guaranteed we find it.
 */
const fetchDailyDrivePodcasts = async (
  appendMessage: (message: string) => void
) => {
  const searchResult = await performRequest(
    `https://api.spotify.com/v1/search/?type=playlist&q="Ruta Diaria"&limit=50`
  );

  const dailyDrive = find(
    searchResult.playlists.items,
    (item) =>
      item.owner.id === "spotify" &&
      (item.name === "Your Daily Drive" ||
        item.name === "Daily Drive" ||
        item.name === "Ruta diaria")
  );

  if (!dailyDrive) {
    appendMessage(
      "Daily Drive playlist could not be found. Skipping including podcasts..."
    );
    return null;
  }

  const allTracks = await fetchAllPlaylistTrackUris(dailyDrive.id);
  const episodes = filter(allTracks, (uri) =>
    startsWith(uri, "spotify:episode:")
  );
  return episodes;
};

export const generateDailyDrive = async (
  name: string,
  blocks: number,
  blockSize: number,
  withPodcasts: boolean,
  appendMessage: (message: string) => void
) => {
  appendMessage(null);
  appendMessage("Fetching user info...");
  const user = await fetchUserInfo();

  if (!user.id) {
    appendMessage("User ID not found.");
    return;
  }

  appendMessage(`Found user with ID ${user.id}.`);

  appendMessage(`Checking for the existence of playlist "${name}"...`);
  let playlist = await getExistingPlaylist(user.id, name);

  if (playlist) {
    appendMessage(`Found existing playlist with ID ${playlist.id}.`);
    appendMessage("Emptying the existing playlist...");
    await emptyPlaylist(playlist.id);
  } else {
    appendMessage(`Creating new playlist "${name}"...`);
    playlist = await createPlaylist(user.id, name);
    appendMessage(`Created playlist with ID ${playlist.id}.`);
  }

  appendMessage("Fetching user's liked tracks...");
  const tracks = await fetchAllSavedTracks();

  appendMessage("Shuffling tracks...");
  const seedTracks = shuffle(tracks)
    .slice(0, blocks)
    .map((i) => i.track);

  const recommendedBlocks = [];

  let episodeUris = null;
  if (withPodcasts) {
    appendMessage("Fetching podcasts from Daily Drive...");
    episodeUris = await fetchDailyDrivePodcasts(appendMessage);
    console.log({ episodeUris });
  }

  await serialAsyncForEach(seedTracks, async (track) => {
    appendMessage("Getting recommendations for liked tracks...");
    const recommendations = await getRecommendations(track.id, blockSize - 1);
    if (episodeUris) {
      const episodeUri = episodeUris.shift();
      if (episodeUri) recommendedBlocks.push(episodeUri);
    }
    recommendedBlocks.push(track.uri);
    recommendedBlocks.push(recommendations.tracks.map((i) => i.uri));
    return;
  });

  // If we have more podcasts left than blocks, we'll add them all in the last block.
  if (episodeUris && episodeUris.length > 0) {
    appendMessage("Adding all extra podcasts at the end of the playlist...");
    recommendedBlocks.push(...episodeUris);
  }

  appendMessage("Adding tracks to the playlist...");
  await addTracks(playlist.id, flattenDeep(recommendedBlocks));
  return playlist;
};
